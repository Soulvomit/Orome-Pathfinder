     1                                  [BITS 64]
     2                                  [SECTION .text]
     3                                  [GLOBAL _Node.Ctor]
     4                                  [GLOBAL _Node.Traceback]
     5                                  [GLOBAL _Node.UpdateAdjecentNode]
     6                                  [GLOBAL _Node.Empty]
     7                                  ;From _Node2D:
     8                                  [EXTERN _Node2D.CalcManhattanDistance]
     9                                  [EXTERN _Node2D.GetByCoordinates]
    10                                  ;From Data - Node
    11                                  [EXTERN Node.Position.Y]
    12                                  [EXTERN Node.Position.X]
    13                                  [EXTERN Node.Resistance]
    14                                  [EXTERN Node.Traversable]
    15                                  [EXTERN Node.Closed]
    16                                  [EXTERN Node.GCost]
    17                                  [EXTERN Node.HCost]
    18                                  [EXTERN Node.FCost]
    19                                  [EXTERN Node.ID]
    20                                  [EXTERN Node.PParent]
    21                                  [EXTERN Node.PNext]
    22                                  [EXTERN Node.Size]
    23                                  [EXTERN Node.BaseCost]
    24                                  ;From Data - NodeStack
    25                                  [EXTERN NodeStack.Top]
    26                                  [EXTERN NodeStack.Bottom]
    27                                  [EXTERN NodeStack.Count]
    28                                  ;From Data - NodeOpenList
    29                                  [EXTERN NodeOpenList.First]
    30                                  [EXTERN NodeOpenList.Last]
    31                                  [EXTERN NodeOpenList.Count]
    32                                  ;From Data - Grid
    33                                  [EXTERN Grid.MapWidth]
    34                                  [EXTERN Grid.MapHeight]
    35                                  [DEFAULT REL]
    36                                   
    37                                  _Node:
    38                                  	;IN: ax = Position.X, bx = Position.Y, cx = Traversable, dx = Resistance.					 
    39                                  	.Ctor:
    40                                  		;caller addr
    41 00000000 5F                      		pop rdi
    42                                  		;NodeStack.Top + (Node.Size*Node.ID) + offset
    43                                  		;push word 0							;Shadow bytes
    44                                  		;push word 0							;Shadow bytes
    45                                  		;push word 0							;Shadow bytes
    46 00000001 6653                    		push bx								;Node.Position.Y: 	offset = 8*7	= 56
    47 00000003 6650                    		push ax								;Node.Position.X: 	offset = 8*6+6 	= 54
    48 00000005 6652                    		push dx 							;Node.Resistance: 	offset = 8*6+4 	= 52
    49 00000007 6651                    		push cx								;Node.Traversable: 	offset = 8*6+2 	= 50
    50 00000009 666A00                  		push word  0						;Node.Closed: 		offset = 8*6 	= 48
    51 0000000C 6A00                    		push qword 0						;Node.GCost: 		offset = 8*5	= 40
    52 0000000E 6A00                    		push qword 0						;Node.HCost: 		offset = 8*4	= 32
    53 00000010 6A00                    		push qword 0						;Node.FCost: 		offset = 8*3	= 24
    54 00000012 FFB5[00000000]          		push qword [rbp + NodeStack.Count]	;Node.ID: 			offset = 8*2	= 16
    55 00000018 6AFF                    		push 0xFFFFFFFFFFFFFFFF				;Node.PParent: 		offset = 8*1	= 8
    56 0000001A 6AFF                    		push 0xFFFFFFFFFFFFFFFF				;Node.PNext: 		offset = 8*0	= 0
    57                                  		;inc node counter
    58 0000001C 48FF85[00000000]        		inc qword [rbp + NodeStack.Count]
    59                                  		;save top ptr
    60 00000023 4889A5[00000000]        		mov qword [rbp + NodeStack.Top], rsp
    61                                  		;return to caller
    62 0000002A 57                      		push rdi
    63 0000002B C3                      		ret
    64                                  		
    65                                  	;IN: ax = OffsetX, bx = OffsetY
    66                                  	;OUT: rcx = 0 if out-of-bounds, 1 if closed or non-traversable, 2 if updated, 
    67                                  	;			3 if sent to update, but not updated, 4 if initialized, 5 if target node 
    68                                  	.UpdateAdjecentNode:
    69                                  		;x,y position for adjecent node
    70 0000002C 66410386[00000000]      		add ax, word [r14 + Node.Position.X]
    71 00000034 6641039E[00000000]      		add bx, word [r14 + Node.Position.Y]
    72                                  		;if adjecent node is out-of-bounds
    73 0000003C 663B85[00000000]        		cmp ax, word [rbp + Grid.MapWidth]
    74 00000043 7D44                    		jge .oob
    75 00000045 6683F800                		cmp ax, 0
    76 00000049 7C3E                    		jl .oob
    77 0000004B 663B9D[00000000]        		cmp bx, word [rbp + Grid.MapHeight]
    78 00000052 7D35                    		jge .oob
    79 00000054 6683FB00                		cmp bx, 0
    80 00000058 7C2F                    		jl .oob
    81                                  		;reference node adjecent to current
    82 0000005A 4831D2                  		xor rdx, rdx 
    83 0000005D 668B95[00000000]        		mov dx, [rbp + Grid.MapWidth]
    84 00000064 E8(00000000)            		call _Node2D.GetByCoordinates
    85                                  		;if it is closed and is non-traversable 
    86 00000069 6683B9[00000000]00      		cmp word [rcx + Node.Closed], 0
    87 00000071 751C                    		jnz .closed_nontraversable
    88 00000073 6683B9[00000000]00      		cmp word [rcx + Node.Traversable], 0
    89 0000007B 7412                    		jz .closed_nontraversable
    90                                  		;check if node should be updated or initialized
    91 0000007D 4883B9[00000000]FF      		cmp qword [rcx + Node.PParent], -1
    92 00000085 742B                    		jz .i_initialized
    93 00000087 750C                    		jnz .u_updated
    94                                  		.oob:
    95 00000089 B900000000              			mov rcx, 0
    96 0000008E C3                      			ret
    97                                  		.closed_nontraversable:
    98 0000008F B901000000              			mov rcx, 1
    99 00000094 C3                      			ret
   100                                  		.u_updated:
   101 00000095 4889C8                  			mov rax, rcx
   102 00000098 4C89F2                  			mov rdx, r14
   103 0000009B E8E4000000              			call private.fUpdate
   104 000000A0 4883F900                			cmp rcx, 0
   105 000000A4 7406                    			jz .u_not_updated
   106 000000A6 B902000000              			mov rcx, 2
   107 000000AB C3                      			ret
   108                                  		.u_not_updated:
   109 000000AC B903000000              			mov rcx, 3
   110 000000B1 C3                      			ret
   111                                  		.i_initialized:
   112 000000B2 4889C8                  			mov rax, rcx
   113 000000B5 4C89FB                  			mov rbx, r15
   114 000000B8 4C89F2                  			mov rdx, r14
   115 000000BB E85F000000              			call private.fInitialize
   116 000000C0 4883F901                			cmp rcx, 1
   117 000000C4 7406                    			jz .i_targetfound
   118 000000C6 B904000000              			mov rcx, 4
   119 000000CB C3                      			ret
   120                                  		.i_targetfound:
   121 000000CC B905000000              			mov rcx, 5
   122 000000D1 C3                      			ret
   123                                  			
   124                                  	;IN: rax = Node.ID
   125                                  	;OUT: rcx = Node Pointer
   126                                  	.GetByID:
   127 000000D2 4C69C0[00000000]        		imul r8, rax, Node.Size
   128 000000D9 488B8D[00000000]        		mov rcx, [rbp + NodeStack.Bottom]
   129 000000E0 4C29C1                  		sub rcx, r8
   130 000000E3 C3                      		ret
   131                                  			
   132                                  	;IN: rax = TargetNode, rbx = POutBuffer, rdx = DWord Index,  rsi = Starting Node, rdi = Pop Counter
   133                                  	;OUT: rcx = Path Length
   134                                  	.Traceback:
   135                                  		;store node id on stack
   136 000000E4 4C8B80[00000000]        		mov r8, [rax + Node.ID]				;Get node id
   137 000000EB 4150                    		push r8								;Push node id to stack
   138 000000ED 48FFC1                  		inc rcx								;Inc path length
   139                                  		;if current traceback nodes parent is not start node
   140 000000F0 4839B0[00000000]        		cmp qword [rax + Node.PParent], rsi
   141 000000F7 7409                    		jz .fill_outbuffer
   142                                  			;recursively traceback through parents
   143 000000F9 488B80[00000000]        			mov rax, [rax + Node.PParent]
   144 00000100 EBE2                    			jmp .Traceback
   145                                  		.fill_outbuffer:
   146                                  			;pop the node id into outbuffer
   147 00000102 4158                    			pop r8
   148 00000104 4C890413                			mov [rbx + rdx], r8
   149 00000108 4883C204                			add rdx, 4
   150 0000010C 48FFC7                  			inc rdi
   151 0000010F 4839CF                  			cmp rdi, rcx
   152 00000112 7402                    			jz .done
   153 00000114 EBEC                    			jmp .fill_outbuffer
   154                                  		.done:
   155 00000116 C3                      			ret
   156                                  		
   157                                  	;Uses rsi,rdi and rbp to access data segment. 
   158                                  	;Empties the node stack. 
   159                                  	;NOTE: Must be called in the same scope as _Node.Ctor
   160                                  	.Empty:
   161 00000117 5D                      		pop rbp
   162                                  		;call sequence
   163 00000118 E8B5010000              		call private.fStackDeallocAll
   164                                  		;call private.fSaveTopAfterRet
   165 0000011D 55                      		push rbp
   166 0000011E C3                      		ret	
   167                                  		
   168                                  	;PRIVATE SUBROUTINES:
   169                                  	private:
   170                                  		;IN: rax = AdjecentNode, rbx = TargetNode, rdx = CurrentNode.
   171                                  		;OUT: rcx = 1 if rax is TargetNode, else 0.
   172                                  		.fInitialize:
   173                                  			;set current node as adjecent nodes parent
   174 0000011F 488990[00000000]        			mov [rax + Node.PParent], rdx
   175                                  			;if this node is target node return 1, else initialize node
   176 00000126 4839D8                  			cmp rax, rbx
   177 00000129 7453                    			jz .target_found
   178                                  				;store parents g cost as adjecent g cost
   179 0000012B 4C8B82[00000000]        				mov r8, [rdx + Node.GCost]				;Get parent g cost from pointer
   180 00000132 4C8980[00000000]        				mov qword [rax + Node.GCost], r8		;Store parent g cost, in adjecent g cost
   181                                  				;add the multiplication of basecost and resistance to adjecent g cost
   182 00000139 4C8B88[00000000]        				mov r9, [rax + Node.Resistance]			;Get resistance multi
   183 00000140 4981E1FFFF0000          				and r9, 0xFFFF							;convert word of r9 into qword
   184 00000147 4C0FAF0D(00000000)      				imul r9, [Node.BaseCost]				;Multiply basecost with resistance
   185 0000014F 4C0188[00000000]        				add qword [rax + Node.GCost], r9		;Add multiplication result to adjecent basecost
   186                                  				;calc manhatten distance to target
   187 00000156 E8(00000000)            				call _Node2D.CalcManhattanDistance
   188                                  				;init h,f costs
   189 0000015B 488988[00000000]        				mov qword [rax + Node.HCost], rcx
   190 00000162 4C8B80[00000000]        				mov r8, [rax + Node.GCost]
   191 00000169 4901C8                  				add r8, rcx
   192 0000016C 4C8980[00000000]        				mov qword [rax + Node.FCost], r8
   193 00000173 E86B000000              				call private.fOpen
   194 00000178 B900000000              				mov rcx, 0
   195 0000017D C3                      				ret	
   196                                  			.target_found:
   197 0000017E B901000000              				mov rcx, 1
   198 00000183 C3                      				ret
   199                                  				
   200                                  		;IN: rax = AdjecentNode, rdx = CurrentNode.
   201                                  		;OUT: rcx = 1 if node was updated, else 0.
   202                                  		.fUpdate:
   203                                  			;compute new g cost
   204 00000184 4C8B82[00000000]        			mov r8, [rdx + Node.GCost]
   205 0000018B 4D89C1                  			mov r9, r8
   206 0000018E 4C8B90[00000000]        			mov r10, [rax + Node.Resistance]
   207 00000195 4981E2FFFF0000          			and r10, 0xFFFF
   208 0000019C 4C0FAF15(00000000)      			imul r10, [Node.BaseCost]
   209 000001A4 4D01D0                  			add r8, r10
   210 000001A7 4C0380[00000000]        			add r8, [rax + Node.HCost]
   211                                  			;if updated f cost is larger then current f cost, don't update
   212 000001AE 4C3B80[00000000]        			cmp r8, [rax + Node.FCost]
   213 000001B5 7F26                    			jg .no_update
   214 000001B7 741B                    			je .tie_breaker
   215                                  			;else update all costs and set new parent; return true
   216                                  			.do_update:
   217                                  				;set current node as adjecent nodes parent
   218 000001B9 488990[00000000]        				mov [rax + Node.PParent], rdx
   219 000001C0 4C8988[00000000]        				mov [rax + Node.GCost], r9
   220 000001C7 4C8980[00000000]        				mov [rax + Node.FCost], r8
   221 000001CE B901000000              				mov rcx, 1
   222 000001D3 C3                      				ret
   223                                  			.tie_breaker:
   224                                  				;if f-costs are equal and path is shorter, do update
   225 000001D4 4C3988[00000000]        				cmp [rax + Node.GCost], r9
   226 000001DB 7CDC                    				jl .do_update
   227                                  			.no_update:
   228 000001DD B900000000              				mov rcx, 0
   229 000001E2 C3                      				ret
   230                                  		
   231                                  		;IN: rax = AdjecentNode.
   232                                  		;OUT: rcx = 0 if new node or new top node, 1 if new bottom node.
   233                                  		.fOpen:
   234 000001E3 4C8B85[00000000]        			mov r8, [rbp + NodeOpenList.First]
   235 000001EA 4983F8FF                			cmp qword r8, -1
   236 000001EE 7417                    			jz .first
   237 000001F0 4D8B90[00000000]        			mov r10, [r8 + Node.FCost]
   238 000001F7 4C3B90[00000000]        			cmp r10, [rax + Node.FCost]
   239 000001FE 7F15                    			jg .new_first
   240 00000200 E82D000000              			call private.fSortedInsert
   241 00000205 EB23                    			jmp .open_done
   242                                  			.first:
   243 00000207 488985[00000000]        				mov [rbp + NodeOpenList.First], rax
   244 0000020E B900000000              				mov rcx, 0
   245 00000213 EB15                    				jmp .open_done
   246                                  			.new_first:
   247 00000215 4C8980[00000000]        				mov [rax + Node.PNext], r8
   248 0000021C 488985[00000000]        				mov [rbp + NodeOpenList.First], rax
   249 00000223 B901000000              				mov rcx, 1
   250 00000228 EB00                    				jmp .open_done
   251                                  			.open_done:
   252 0000022A 48FF85[00000000]        				inc qword [rbp + NodeOpenList.Count]
   253 00000231 C3                      				ret
   254                                  			
   255                                  		;IN: rax = AdjecentNode.
   256                                  		;OUT: rcx = 3 if node was allocated based on f-cost, rcx = 4 if node was allocated based on h-cost.
   257                                  		.fSortedInsert:
   258 00000232 4C8B85[00000000]        			mov r8, [rbp + NodeOpenList.First]	;save first in open list = current node
   259                                  			.next_open_node:
   260 00000239 4D89C2                  				mov r10, r8						;save current topframe
   261 0000023C 4D8B80[00000000]        				mov r8, [r8 + Node.PNext]		;save current topframes next node
   262 00000243 4983F8FF                				cmp qword r8, -1
   263 00000247 7424                    				jz .new_last
   264                                  				;check costs
   265 00000249 4C8B88[00000000]        				mov r9, [rax + Node.FCost]		;save adjecents f-cost
   266 00000250 4D3B8A[00000000]        				cmp r9, [r10 + Node.FCost]		;compare adjecents f-cost with topframes f-cost
   267 00000257 7FE0                    				jg .next_open_node				;if adjecent is more f-expensive, start new frame
   268 00000259 7C1F                    				jl .node_is_cheaper_f			;if adjecent is f-cheaper, link sequence
   269                                  				;tie-breaker 
   270 0000025B 4C8B88[00000000]        				mov r9, [rax + Node.HCost]		;save adjecents h-cost
   271 00000262 4D3B8A[00000000]        				cmp r9, [r10 + Node.HCost]		;compare adjecents h-cost with topfames h-cost
   272 00000269 7FCE                    				jg .next_open_node				;if adjecent is more h-expensive, start new frame
   273 0000026B 7E14                    				jle .node_is_cheaper_h			;if adjecent is h-cheaper or equal, link sequence
   274                                  				.new_last:
   275 0000026D 498982[00000000]        					mov [r10 + Node.PNext], rax	;link current topframe to adjecent
   276 00000274 B902000000              					mov rcx, 2					;return 2
   277 00000279 C3                      					ret
   278                                  				.node_is_cheaper_f:
   279 0000027A B903000000              					mov rcx, 3					;return 3
   280 0000027F EB07                    					jmp .node_is_cheaper
   281                                  				.node_is_cheaper_h:
   282 00000281 B904000000              					mov rcx, 4 					;return 4
   283 00000286 EB00                    					jmp .node_is_cheaper
   284                                  				.node_is_cheaper:
   285 00000288 498982[00000000]        					mov [r10 + Node.PNext], rax	;link current topframe to adjecent
   286 0000028F 4C8980[00000000]        					mov [rax + Node.PNext], r8	;link adjecent to topframes next node
   287 00000296 C3                      					ret
   288                                  
   289                                  		;Uses rbp to access data segment.
   290                                  		;Removes node on top of stack, saves values in regs.
   291                                  		.fPop:
   292 00000297 5D                      			pop rbp		;caller addr
   293 00000298 49FF89[00000000]        			dec qword [r9 + NodeStack.Count]
   294                                  			;pop sequence
   295 0000029F 58                      			pop rax		;Node.PNext
   296 000002A0 5B                      			pop rbx		;Node.PParent
   297 000002A1 5A                      			pop rdx		;Node.ID
   298 000002A2 4158                    			pop r8		;Node.FCost
   299 000002A4 4159                    			pop r9		;Node.HCost
   300 000002A6 415A                    			pop r10		;Node.GCost
   301 000002A8 415B                    			pop r11		;Node.Closed
   302 000002AA 415C                    			pop r12		;Node.Traversable
   303 000002AC 415D                    			pop r13		;Node.Resistance
   304 000002AE 415E                    			pop r14		;Node.Position.Y
   305 000002B0 415F                    			pop r15		;Node.Position.X
   306                                  			;save top ptr
   307 000002B2 4989A1[00000000]        			mov [r9 + NodeStack.Top], rsp
   308                                  			;return
   309 000002B9 55                      			push rbp
   310 000002BA C3                      			ret
   311                                  			
   312                                  		;Uses rsi,rdi to access data segment. 
   313                                  		;Removes node on top of stack, faster then PopTop.
   314                                  		.fRemoveTop:
   315 000002BB 5D                      			pop rbp
   316                                  			;call sequence
   317 000002BC E807000000              			call private.fStackDeallocOne
   318 000002C1 E833000000              			call private.fSaveTopAfterRet
   319                                  			;ret
   320 000002C6 55                      			push rbp
   321 000002C7 C3                      			ret
   322                                  			
   323                                  		;deallocates top node
   324                                  		.fStackDeallocOne:
   325                                  			;dec node counter
   326 000002C8 49FF89[00000000]        			dec qword [r9 + NodeStack.Count]
   327                                  			;ret and remove last node
   328 000002CF C2[0000]                			ret Node.Size
   329                                  			
   330                                  		;deallocates all nodes
   331                                  		.fStackDeallocAll:
   332 000002D2 5F                      			pop rdi
   333                                  			;remove all nodes
   334 000002D3 48BE-                   			mov rsi, Node.Size
   334 000002D5 [0000000000000000] 
   335 000002DD 490FAFB1[00000000]      			imul rsi, [r9 + NodeStack.Count]
   336 000002E5 4801F4                  			add rsp, rsi
   337 000002E8 4883C458                			add rsp, 88
   338                                  			;null node counter
   339 000002EC 49C781[00000000]00-     			mov qword [r9 + NodeStack.Count], 0
   339 000002F4 000000             
   340 000002F7 57                      			push rdi
   341 000002F8 C3                      			ret
   342                                  			
   343                                  		;saves top ptr after correctly a ret needed for some subroutines
   344                                  		.fSaveTopAfterRet:
   345                                  			;save base ptr
   346 000002F9 4889A5[00000000]        			mov [rbp + NodeStack.Top], rsp
   347 00000300 8385[00000000]08        			add dword [rbp + NodeStack.Top], 0x8
   348 00000307 C3                      			ret
   349                                  			
   350                                  		;saves top ptr
   351                                  		.fSaveTopBeforeRet:
   352                                  			;save base ptr
   353 00000308 4889A5[00000000]        			mov [rbp + NodeStack.Top], rsp
   354 0000030F C3                      			ret
