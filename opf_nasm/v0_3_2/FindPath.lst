     1                                  ;Author:	Jonas Brown
     2                                  ;Date:		27/12-2016
     3                                  ;File: 		FindPath.asm
     4                                  
     5                                  [BITS 64]
     6                                  [SECTION .text]
     7                                  [GLOBAL DllMain]
     8                                  [GLOBAL FindPath]
     9                                  [EXPORT DllMain]
    10                                  [EXPORT FindPath]
    11                                  ;From _Node:
    12                                  [EXTERN _Node.Ctor]
    13                                  [EXTERN _Node.UpdateAdjecentNode]
    14                                  [EXTERN _Node.Empty]
    15                                  [EXTERN _Node.Traceback]
    16                                  ;From _Node2D:
    17                                  [EXTERN _Node2D.GetByCoordinates]
    18                                  ;From Data - Node
    19                                  [EXTERN Node.Closed]
    20                                  [EXTERN Node.Traversable]
    21                                  [EXTERN Node.Size]
    22                                  [EXTERN Node.PNext]
    23                                  [EXTERN Node.HCost]
    24                                  [EXTERN Node.FCost]
    25                                  [EXTERN Node.AdjecentOffsets]
    26                                  ;From Data - NodeStack
    27                                  [EXTERN NodeStack.Bottom]
    28                                  ;From Data - NodeOpenList
    29                                  [EXTERN NodeOpenList.First]
    30                                  [EXTERN NodeOpenList.Last]
    31                                  [EXTERN NodeOpenList.Count]
    32                                  ;From Data - Grid
    33                                  [EXTERN Grid.IncludeDiagonals]
    34                                  [EXTERN Grid.TargetX]
    35                                  [EXTERN Grid.TargetY]
    36                                  [EXTERN Grid.StartX]
    37                                  [EXTERN Grid.StartY]
    38                                  [EXTERN Grid.PStartNode]
    39                                  [EXTERN Grid.MapWidth]
    40                                  [EXTERN Grid.MapHeight]
    41                                  [EXTERN Grid.POutBuffer]
    42                                  [EXTERN Grid.PMap]
    43                                  ;TEST
    44                                  ;[EXTERN TestData.PMap]
    45                                  ;[EXTERN TestData.POutBuffer]
    46                                  [DEFAULT REL]
    47                                  
    48                                  DllMain:
    49                                  	;FOR TESTING: Simulates fastcall64
    50                                  	;mov ecx, 0						;nStartX@0
    51                                  	;mov edx, 0						;nStartY@8
    52                                  	;mov r8d, 31					;nTargetX@16
    53                                  	;mov r9d, 31					;nTargetX@24
    54                                  	;mov rax, TestData.PMap			;pMap@32
    55                                  	;mov [rsp + 32], rax	
    56                                  	;mov eax, 32 					;nMapWidth@40
    57                                  	;mov [rsp + 40], eax			
    58                                  	;mov eax, 32  					;nMapHeight@48
    59                                  	;mov [rsp + 48], eax			
    60                                  	;mov rax, TestData.POutBuffer	;pOutBuffer@56
    61                                  	;mov [rsp + 56], rax
    62                                  	;mov eax, 1024					;nOutBufferSize@64
    63                                  	;mov [rsp + 64], eax			
    64                                  	;mov eax, 1						;nIncludeDiagonals@72
    65                                  	;mov [rsp + 72], eax		
    66                                  	;call FindPath
    67 00000000 B801000000                  mov eax, 1
    68 00000005 C3                          ret
    69                                  
    70                                  ;INTERFACE: fastcall64
    71                                  ;typedef int(*ASM_INTERFACE)(const int nStartX, const int nStartY, const int nTargetX, const int nTargetY, 
    72                                  ;const unsigned char* pMap, const int nMapWidth, const int nMapHeight, int* pOutBuffer, const int nOutBufferSize) 
    73                                  FindPath:
    74                                  	;check if start x coord is out-of-bounds
    75 00000006 3B4C2430                	cmp ecx, [rsp + 48]
    76 0000000A 0F8D50020000            	jge .no_path_found
    77 00000010 83F900                  	cmp ecx, 0
    78 00000013 0F8C47020000            	jl .no_path_found
    79                                  	;check if start y coord is out-of-bounds
    80 00000019 3B542438                	cmp edx, [rsp + 56]
    81 0000001D 0F8D3D020000            	jge .no_path_found
    82 00000023 83FA00                  	cmp edx, 0
    83 00000026 0F8C34020000            	jl .no_path_found
    84                                  	;check if target x coord is out-of-bounds
    85 0000002C 443B442430              	cmp r8d, [rsp + 48]
    86 00000031 0F8D29020000            	jge .no_path_found
    87 00000037 4183F800                	cmp r8d, 0
    88 0000003B 0F8C1F020000            	jl .no_path_found
    89                                  	;check if target x coord is out-of-bounds
    90 00000041 443B4C2438              	cmp r9d, [rsp + 56]
    91 00000046 0F8D14020000            	jge .no_path_found
    92 0000004C 4183F900                	cmp r9d, 0
    93 00000050 0F8C0A020000            	jl .no_path_found
    94                                  	;initialize "per execution" tls data
    95 00000056 4889E5                  	mov rbp, rsp			;save the stack ptr
    96 00000059 6A00                    	push qword 0			;Grid.PStartNode@80
    97 0000005B 488B4528                	mov rax, [rbp + 40]		;Grid.PMap@72
    98 0000005F 50                      	push rax				
    99 00000060 488B4540                	mov rax, [rbp + 64]		;Grid.POutBuffer@64
   100 00000064 50                      	push rax				
   101 00000065 488B4548                	mov rax, [rbp + 72]		;Grid.OutBufferSize@62
   102 00000069 6650                    	push ax					
   103 0000006B 488B4538                	mov rax, [rbp + 56]		;Grid.MapHeight@60
   104 0000006F 6650                    	push ax					
   105 00000071 488B4530                	mov rax, [rbp + 48]		;Grid.MapWidth@58
   106 00000075 6650                    	push ax					
   107 00000077 664151                  	push r9w				;Grid.TargetY@56
   108 0000007A 664150                  	push r8w				;Grid.TargetX@54
   109 0000007D 6652                    	push dx					;Grid.StartY@52
   110 0000007F 6651                    	push cx					;Grid.StartX@50
   111 00000081 488B4550                	mov rax, [rbp + 80]		;Grid.IncludeDiagonals@48
   112 00000085 4883F801                	cmp rax, 1					;if IncludeDiagonals == true
   113 00000089 7406                    	jz .includediagonals		;jmp to include digonals
   114 0000008B 66B80400                		mov ax, 4				;else, mov ax, 4 
   115 0000008F EB04                    		jmp .ignorediagonals	;and ignore diagonals
   116                                  	.includediagonals:
   117 00000091 66B80800                		mov ax, 8				;mov ax, 8
   118                                  	.ignorediagonals:
   119 00000095 6650                    	push word ax				;store ax on stack
   120 00000097 6A00                    	push qword 0			;NodeOpenList.Count@40
   121 00000099 6A00                    	push qword 0			;NodeOpenList.Last@32
   122 0000009B 6A00                    	push qword 0			;NodeOpenList.First@24
   123 0000009D 6A00                    	push qword 0			;NodeStack.Count@16
   124 0000009F 6A00                    	push qword 0			;NodeStack.Bottom@8
   125 000000A1 6A00                    	push qword 0			;NodeStack.Top@0
   126 000000A3 4889E5                  	mov rbp, rsp			;save the stack ptr to the thread local storage
   127                                  	;initialize values for node creation
   128 000000A6 4889A5[00000000]        	mov [rbp + NodeStack.Bottom], rsp   			;set bottom node to stack pointer
   129 000000AD 4881AD[00000000]-       	sub qword [rbp + NodeStack.Bottom], Node.Size	;add size bottom node
   129 000000B4 [00000000]         
   130 000000B8 6631C9                  	xor cx, cx										;clean rcx
   131 000000BB 4D31C0                  	xor r8, r8				 	  					;row counter
   132 000000BE 4D31C9                  	xor r9, r9				  						;col counter
   133 000000C1 4D31D2                  	xor r10, r10 				  					;node counter
   134 000000C4 4C8B9D[00000000]        	mov r11, [rbp + Grid.PMap]			  			;ptr to map buffer
   135 000000CB 4C8BA5[00000000]        	mov r12, [rbp + Grid.MapWidth]					;move MapWidth into r12	
   136 000000D2 4C8BAD[00000000]        	mov r13, [rbp + Grid.MapHeight]					;move MapHieght into r13
   137 000000D9 4981E4FFFF0000          	and r12, 0xFFFF									;convert word of r12 into qword
   138 000000E0 4981E5FFFF0000          	and r13, 0xFFFF									;convert word of r13 into qword
   139 000000E7 4D0FAFE5                	imul r12, r13									;multiply r12 with MapHeight
   140                                  	;create nodes on stack from grid
   141                                  	.alloc:									;entry of stack alloction loop
   142 000000EB 4D39E2                  		cmp r10, r12						;check for last node in map 
   143 000000EE 742F                    		jz .find_path						;if last node, terminate alloc loop
   144 000000F0 66443B8D[00000000]      			cmp r9w, [rbp + Grid.MapWidth]	;check for last node in row
   145 000000F8 741D                    			jz .switch_row					;if last node in row, row switch
   146 000000FA 664489C8                			mov ax, r9w						;ARG: X
   147 000000FE 664489C3                			mov bx, r8w						;ARG: Y
   148 00000102 438A0C13                			mov cl, [r11+r10]				;ARG: Traversable
   149 00000106 438A1413                			mov dl, [r11+r10]			    ;ARG: Resistance
   150 0000010A E8(00000000)            			call _Node.Ctor					;call constructor
   151 0000010F 49FFC2                  			inc r10							;inc node counter
   152 00000112 49FFC1                  			inc r9							;inc row counter
   153 00000115 EBD4                    			jmp .alloc						;continue alloc loop
   154                                  			.switch_row:					;entry of row switch
   155 00000117 49FFC0                  				inc r8						;inc col counter
   156 0000011A 4D31C9                  				xor r9, r9					;reset row counter
   157 0000011D EBCC                    				jmp .alloc					;continue alloc loop
   158                                  	
   159                                  	.find_path:
   160                                  		;store addr of target node in r15
   161 0000011F 668B85[00000000]        		mov ax, [rbp + Grid.TargetX]			;store TargetX in ax
   162 00000126 668B9D[00000000]        		mov bx, [rbp + Grid.TargetY]			;store TargetY in bx
   163 0000012D 668B95[00000000]        		mov dx, [rbp + Grid.MapWidth]			;store MapWidth in dx
   164 00000134 4825FFFF0000            		and rax, 0xFFFF							;clear the high bits of rax
   165 0000013A 4881E3FFFF0000          		and rbx, 0xFFFF							;clear the high bits of rbx
   166 00000141 4881E2FFFF0000          		and rdx, 0xFFFF							;clear the high bits of rdx
   167 00000148 E8(00000000)            		call _Node2D.GetByCoordinates			;call GetByCoord to get the target node
   168 0000014D 6683B9[00000000]00      		cmp word [rcx + Node.Traversable], 0	;if target node is not traversable
   169 00000155 0F840D010000            		jz .no_path_found_1						;no path can be found
   170 0000015B 4989CF                  		mov r15, rcx							;else, store the target node in r15
   171                                  		;store addr of starting node as first and last on open list
   172 0000015E 668B85[00000000]        		mov ax, [rbp + Grid.StartX]				;store StartX in ax
   173 00000165 668B9D[00000000]        		mov bx, [rbp + Grid.StartY]				;store StartY in bx
   174 0000016C 668B95[00000000]        		mov dx, [rbp + Grid.MapWidth]			;store MapWidth in dx
   175                                  		;no need to clear high bits of regs, since they are still cleared
   176 00000173 E8(00000000)            		call _Node2D.GetByCoordinates			;call GetByCoord to get the start node
   177 00000178 6683B9[00000000]00      		cmp word [rcx + Node.Traversable], 0	;if start node is not traversable
   178 00000180 0F84EB000000            		jz .no_path_found_2						;no path can be found
   179 00000186 48898D[00000000]        		mov qword [rbp + Grid.PStartNode], rcx			;save a ptr to start node
   180 0000018D 48898D[00000000]        		mov qword [rbp + NodeOpenList.First], rcx		;add start node as the first in open list
   181                                  		;mov qword [rcx + Node.PNext], rcx				;add start node as its own PNext: SHOULD WE DO THIS?
   182 00000194 48C781[00000000]FF-     		mov qword [rcx + Node.HCost], 0x1FFFFFFF		;add dummy value as HCost
   182 0000019C FFFF1F             
   183 0000019F 48C781[00000000]FF-     		mov qword [rcx + Node.FCost], 0x1FFFFFFF		;add dummy value as FCost
   183 000001A7 FFFF1F             
   184 000001AA 48FF85[00000000]        		inc qword [rbp + NodeOpenList.Count]			;inc open list count		
   185                                  		;find path sequence
   186                                  		;xor r12w, r12w									;ready r12w
   187                                  		;xor rdi, rdi									;ready failsafe counter
   188                                  		.next_open:
   189                                  			;ready current node, store
   190 000001B1 4C8BB5[00000000]        			mov r14, [rbp + NodeOpenList.First]			;get new current node
   191                                  			;fail safe check, might not be necessary
   192 000001B8 4883BD[00000000]FF      			cmp qword [rbp + NodeOpenList.First], -1	;check that current node has a valid link
   193 000001C0 0F84B4000000            			jz .no_path_found_3							;jump to "no path" if it doesn't
   194 000001C6 6641C786[00000000]-     			mov word [r14 + Node.Closed], 1				;close current node
   194 000001CE 0100               
   195                                  			;ready NodeOpenList.First node, pop
   196 000001D0 4D8B9E[00000000]        			mov r11, [r14 + Node.PNext]					;get current.PNext
   197 000001D7 4C899D[00000000]        			mov [rbp + NodeOpenList.First], r11			;set OpenList.First to current.PNext
   198 000001DE 49C786[00000000]FF-     			mov qword [r14 + Node.PNext], -1			;current - set PNext to -1 
   198 000001E6 FFFFFF             
   199                                  			;check if open list is empty
   200 000001E9 4883BD[00000000]00      			cmp qword [rbp + NodeOpenList.Count], 0		;if open list count = 0
   201 000001F1 0F848C000000            			jz .no_path_found_4							;jump to "no path"
   202 000001F7 48FF8D[00000000]        			dec qword [rbp + NodeOpenList.Count]		;else, dec open list count
   203                                  			;ready adjecent check proc
   204 000001FE 4D31DB                  			xor r11, r11								;reset r11
   205 00000201 49BD-                   			mov r13, Node.AdjecentOffsets				;starting adjecent offset
   205 00000203 [0000000000000000] 
   206                                  			;update the current node adjecent nodes
   207                                  			.next_adjecent:
   208 0000020B 4831C0                  				xor rax, rax							;reset rax
   209 0000020E 4831DB                  				xor rbx, rbx							;reset rbx
   210 00000211 66418B4500              				mov ax, word [r13]						;ARG: OffsetX
   211 00000216 66418B5D08              				mov bx, word [r13 + 8]					;ARG: OffsetY
   212 0000021B E8(00000000)            				call _Node.UpdateAdjecentNode			;call UpdateAdjecentNode
   213 00000220 4883F905                				cmp rcx, 5								;check if target is found
   214 00000224 7416                    				jz .path_found							;jump to "path found" if it is
   215 00000226 4983C510                				add r13, 16								;add 16 to offset
   216 0000022A 49FFC3                  				inc r11									;inc iteration counter
   217 0000022D 66443B9D[00000000]      				cmp r11w, [rbp + Grid.IncludeDiagonals]	;check for last offset
   218 00000235 75D4                    				jnz .next_adjecent						;if last offset, terminate adjecent loop
   219                                  			;iteration failsafe
   220                                  			;inc rdi									;inc iteration counter
   221                                  			;cmp rdi, 3000000							;if counter is above failsafe 
   222                                  			;jge .no_path_found_5						;jump to "no path" if failsafe is hit
   223 00000237 E975FFFFFF              			jmp .next_open								;else, check next open node
   224                                  		.path_found:
   225 0000023C 4C89F8                  			mov rax, r15								;store target node in rax
   226 0000023F 488B9D[00000000]        			mov rbx, [rbp + Grid.POutBuffer]			;store ptr to outbuffer in rbx
   227 00000246 4831C9                  			xor rcx, rcx								;ready rcx
   228 00000249 4831D2                  			xor rdx, rdx								;ready rdx
   229 0000024C 4831FF                  			xor rdi, rdi								;ready rdi
   230 0000024F 488BB5[00000000]        			mov rsi, [rbp + Grid.PStartNode]			;store ptr to start node in rsi
   231 00000256 E8(00000000)            			call _Node.Traceback						;call _Node.Traceback to store the final path in outbuffer
   232 0000025B 4889C8                  			mov rax, rcx								;store ptr to outbuffer in rax
   233 0000025E EB35                    			jmp .pf_done								;jump to pf_done
   234                                  		.no_path_found:
   235 00000260 48C7C0FFFFFFFF          			mov rax, -1			;start or target is out-of-bounds of map
   236 00000267 C3                      			ret					;return
   237                                  		.no_path_found_1:
   238 00000268 48C7C0FEFFFFFF          			mov rax, -2			;target node is non-traversable
   239 0000026F EB24                    			jmp .pf_done		;jump to pf_done
   240                                  		.no_path_found_2:
   241 00000271 48C7C0FDFFFFFF          			mov rax, -3			;start node is non-traversable
   242 00000278 EB1B                    			jmp .pf_done		;jump to pf_done
   243                                  		.no_path_found_3:
   244 0000027A 48C7C0FCFFFFFF          			mov rax, -4			;PNext is -1, failsafe
   245 00000281 EB12                    			jmp .pf_done		;jump to pf_done
   246                                  		.no_path_found_4:
   247 00000283 48C7C0FBFFFFFF          			mov rax, -5			;open list is empty
   248 0000028A EB09                    			jmp .pf_done		;jump to pf_done
   249                                  		.no_path_found_5:
   250 0000028C 48C7C0FAFFFFFF          			mov rax, -6			;path is too long
   251 00000293 EB00                    			jmp .pf_done		;jump to pf_done
   252                                  		.pf_done:
   253 00000295 4989E9                  			mov r9, rbp			;save rbp in r9
   254 00000298 E8(00000000)            			call _Node.Empty	;empty nodes
   255 0000029D C3                      			ret					;return
