     1                                  ;Author:	Jonas Brown
     2                                  ;Date:		27/12-2016
     3                                  ;File: 		Node.asm
     4                                  
     5                                  [BITS 64]
     6                                  [SECTION .text]
     7                                  [GLOBAL _Node.Ctor]
     8                                  [GLOBAL _Node.Traceback]
     9                                  [GLOBAL _Node.UpdateAdjecentNode]
    10                                  [GLOBAL _Node.Empty]
    11                                  ;From _Node2D:
    12                                  [EXTERN _Node2D.CalcManhattanDistance]
    13                                  [EXTERN _Node2D.GetByCoordinates]
    14                                  ;From Data - Node
    15                                  [EXTERN Node.Position.Y]
    16                                  [EXTERN Node.Position.X]
    17                                  [EXTERN Node.Resistance]
    18                                  [EXTERN Node.Traversable]
    19                                  [EXTERN Node.Closed]
    20                                  [EXTERN Node.GCost]
    21                                  [EXTERN Node.HCost]
    22                                  [EXTERN Node.FCost]
    23                                  [EXTERN Node.ID]
    24                                  [EXTERN Node.PParent]
    25                                  [EXTERN Node.PNext]
    26                                  [EXTERN Node.Size]
    27                                  [EXTERN Node.BaseCost]
    28                                  ;From Data - NodeStack
    29                                  [EXTERN NodeStack.Top]
    30                                  [EXTERN NodeStack.Bottom]
    31                                  [EXTERN NodeStack.Count]
    32                                  ;From Data - NodeOpenList
    33                                  [EXTERN NodeOpenList.First]
    34                                  [EXTERN NodeOpenList.Last]
    35                                  [EXTERN NodeOpenList.Count]
    36                                  ;From Data - Grid
    37                                  [EXTERN Grid.MapWidth]
    38                                  [EXTERN Grid.MapHeight]
    39                                  [EXTERN Grid.OutBufferSize]
    40                                  [DEFAULT REL]
    41                                   
    42                                  _Node:
    43                                  	;IN: ax = Position.X, bx = Position.Y, cx = Traversable, dx = Resistance.					 
    44                                  	.Ctor:
    45                                  		;caller addr
    46 00000000 5F                      		pop rdi
    47                                  		;NodeStack.Top + (Node.Size*Node.ID) + offset
    48                                  		;push word 0						;Shadow bytes
    49                                  		;push word 0						;Shadow bytes
    50                                  		;push word 0						;Shadow bytes
    51 00000001 6653                    		push bx								;Node.Position.Y: 	offset = 8*7	= 56
    52 00000003 6650                    		push ax								;Node.Position.X: 	offset = 8*6+6 	= 54
    53 00000005 6652                    		push dx 							;Node.Resistance: 	offset = 8*6+4 	= 52
    54 00000007 6651                    		push cx								;Node.Traversable: 	offset = 8*6+2 	= 50
    55 00000009 666A00                  		push word  0						;Node.Closed: 		offset = 8*6 	= 48
    56 0000000C 6A00                    		push qword 0						;Node.GCost: 		offset = 8*5	= 40
    57 0000000E 6A00                    		push qword 0						;Node.HCost: 		offset = 8*4	= 32
    58 00000010 6A00                    		push qword 0						;Node.FCost: 		offset = 8*3	= 24
    59 00000012 FFB5[00000000]          		push qword [rbp + NodeStack.Count]	;Node.ID: 			offset = 8*2	= 16
    60 00000018 6AFF                    		push 0xFFFFFFFFFFFFFFFF				;Node.PParent: 		offset = 8*1	= 8
    61 0000001A 6AFF                    		push 0xFFFFFFFFFFFFFFFF				;Node.PNext: 		offset = 8*0	= 0
    62                                  		;inc node counter
    63 0000001C 48FF85[00000000]        		inc qword [rbp + NodeStack.Count]
    64                                  		;save top ptr
    65 00000023 4889A5[00000000]        		mov qword [rbp + NodeStack.Top], rsp
    66                                  		;return to caller
    67 0000002A 57                      		push rdi
    68 0000002B C3                      		ret
    69                                  		
    70                                  	;IN: ax = OffsetX, bx = OffsetY
    71                                  	;OUT: rcx = 0 if out-of-bounds, 1 if closed or non-traversable, 2 if updated, 
    72                                  	;			3 if sent to update, but not updated, 4 if initialized, 5 if target node 
    73                                  	.UpdateAdjecentNode:
    74                                  		;x,y position for adjecent node
    75 0000002C 66410386[00000000]      		add ax, word [r14 + Node.Position.X]
    76 00000034 6641039E[00000000]      		add bx, word [r14 + Node.Position.Y]
    77                                  		;if adjecent node is out-of-bounds
    78 0000003C 663B85[00000000]        		cmp ax, word [rbp + Grid.MapWidth]
    79 00000043 7D44                    		jge .oob
    80 00000045 6683F800                		cmp ax, 0
    81 00000049 7C3E                    		jl .oob
    82 0000004B 663B9D[00000000]        		cmp bx, word [rbp + Grid.MapHeight]
    83 00000052 7D35                    		jge .oob
    84 00000054 6683FB00                		cmp bx, 0
    85 00000058 7C2F                    		jl .oob
    86                                  		;reference node adjecent to current
    87 0000005A 4831D2                  		xor rdx, rdx 
    88 0000005D 668B95[00000000]        		mov dx, [rbp + Grid.MapWidth]
    89 00000064 E8(00000000)            		call _Node2D.GetByCoordinates
    90                                  		;if it is closed and is non-traversable 
    91 00000069 6683B9[00000000]00      		cmp word [rcx + Node.Closed], 0
    92 00000071 751C                    		jnz .closed_nontraversable
    93 00000073 6683B9[00000000]00      		cmp word [rcx + Node.Traversable], 0
    94 0000007B 7412                    		jz .closed_nontraversable
    95                                  		;check if node should be updated or initialized
    96 0000007D 4883B9[00000000]FF      		cmp qword [rcx + Node.PParent], -1
    97 00000085 742B                    		jz .i_initialized
    98 00000087 750C                    		jnz .u_updated
    99                                  		.oob:
   100 00000089 B900000000              			mov rcx, 0
   101 0000008E C3                      			ret
   102                                  		.closed_nontraversable:
   103 0000008F B901000000              			mov rcx, 1
   104 00000094 C3                      			ret
   105                                  		.u_updated:
   106 00000095 4889C8                  			mov rax, rcx
   107 00000098 4C89F2                  			mov rdx, r14
   108 0000009B E8ED000000              			call private.fUpdate
   109 000000A0 4883F900                			cmp rcx, 0
   110 000000A4 7406                    			jz .u_not_updated
   111 000000A6 B902000000              			mov rcx, 2
   112 000000AB C3                      			ret
   113                                  		.u_not_updated:
   114 000000AC B903000000              			mov rcx, 3
   115 000000B1 C3                      			ret
   116                                  		.i_initialized:
   117 000000B2 4889C8                  			mov rax, rcx
   118 000000B5 4C89FB                  			mov rbx, r15
   119 000000B8 4C89F2                  			mov rdx, r14
   120 000000BB E868000000              			call private.fInitialize
   121 000000C0 4883F901                			cmp rcx, 1
   122 000000C4 7406                    			jz .i_targetfound
   123 000000C6 B904000000              			mov rcx, 4
   124 000000CB C3                      			ret
   125                                  		.i_targetfound:
   126 000000CC B905000000              			mov rcx, 5
   127 000000D1 C3                      			ret
   128                                  				
   129                                  	;IN: rax = TargetNode, rbx = POutBuffer, rdx = DWord Index,  rsi = Starting Node, rdi = Pop Counter
   130                                  	;OUT: rcx = Path Length
   131                                  	.Traceback:
   132                                  		;store node id on stack
   133 000000D2 4C8B80[00000000]        		mov r8, [rax + Node.ID]					;get node id
   134 000000D9 4150                    		push r8									;push node id to stack
   135 000000DB 48FFC1                  		inc rcx									;inc path length
   136 000000DE 663B8D[00000000]        		cmp cx, word [rbp + Grid.OutBufferSize]	;if path length = buffer size
   137 000000E5 7412                    		jz .fill_outbuffer						;fill out buffer with path ids
   138 000000E7 4839B0[00000000]        		cmp qword [rax + Node.PParent], rsi		;if start node = parent
   139 000000EE 7409                    		jz .fill_outbuffer						;fill out buffer with path ids
   140                                  			;else, recursively traceback through parents
   141 000000F0 488B80[00000000]        			mov rax, [rax + Node.PParent]		;else, store parent in rax 
   142 000000F7 EBD9                    			jmp .Traceback						;continue traceback
   143                                  		.fill_outbuffer:
   144                                  			;pop the node id into outbuffer
   145 000000F9 4158                    			pop r8					;pop r8 = next in path
   146 000000FB 4C890413                			mov [rbx + rdx], r8		;store next node in path in outbuffer
   147 000000FF 4883C204                			add rdx, 4				;add size of dword to rdx
   148 00000103 48FFC7                  			inc rdi					;inc rdi = counter
   149 00000106 4839CF                  			cmp rdi, rcx			;if counter = path length
   150 00000109 7402                    			jz .done				;job done!
   151 0000010B EBEC                    			jmp .fill_outbuffer		;else, continue to fill outbuffer
   152                                  		.done:
   153 0000010D C3                      			ret						;return
   154                                  
   155                                  	;IN: rax = Node.ID
   156                                  	;OUT: rcx = Node Pointer
   157                                  	.GetByID:
   158 0000010E 4C69C0[00000000]        		imul r8, rax, Node.Size
   159 00000115 488B8D[00000000]        		mov rcx, [rbp + NodeStack.Bottom]
   160 0000011C 4C29C1                  		sub rcx, r8
   161 0000011F C3                      		ret
   162                                  
   163                                  	;Uses rsi,rdi and rbp to access data segment. 
   164                                  	;Empties the node stack. NOTE: Must be called in the same "scope" as _Node.Ctor
   165                                  	.Empty:
   166 00000120 5D                      		pop rbp
   167                                  		;call sequence
   168 00000121 E8B5010000              		call private.fStackDeallocAll
   169                                  		;call private.fSaveTopAfterRet
   170 00000126 55                      		push rbp
   171 00000127 C3                      		ret	
   172                                  		
   173                                  	;PRIVATE SUBROUTINES
   174                                  	private:
   175                                  		;IN: rax = AdjecentNode, rbx = TargetNode, rdx = CurrentNode.
   176                                  		;OUT: rcx = 1 if rax is TargetNode, else 0.
   177                                  		.fInitialize:
   178                                  			;set current node as adjecent nodes parent
   179 00000128 488990[00000000]        			mov [rax + Node.PParent], rdx
   180                                  			;if this node is target node return 1, else initialize node
   181 0000012F 4839D8                  			cmp rax, rbx
   182 00000132 7453                    			jz .target_found
   183                                  				;store parents g cost as adjecent g cost
   184 00000134 4C8B82[00000000]        				mov r8, [rdx + Node.GCost]				;get parent g cost from pointer
   185 0000013B 4C8980[00000000]        				mov qword [rax + Node.GCost], r8		;store parent g cost, in adjecent g cost
   186                                  				;add the multiplication of basecost and resistance to adjecent g cost
   187 00000142 4C8B88[00000000]        				mov r9, [rax + Node.Resistance]			;get resistance multi
   188 00000149 4981E1FFFF0000          				and r9, 0xFFFF							;convert word of r9 into qword
   189 00000150 4C0FAF0D(00000000)      				imul r9, [Node.BaseCost]				;multiply basecost with resistance
   190 00000158 4C0188[00000000]        				add qword [rax + Node.GCost], r9		;add multiplication result to adjecent basecost
   191                                  				;calc manhatten distance to target
   192 0000015F E8(00000000)            				call _Node2D.CalcManhattanDistance
   193                                  				;init h,f costs
   194 00000164 488988[00000000]        				mov qword [rax + Node.HCost], rcx
   195 0000016B 4C8B80[00000000]        				mov r8, [rax + Node.GCost]
   196 00000172 4901C8                  				add r8, rcx
   197 00000175 4C8980[00000000]        				mov qword [rax + Node.FCost], r8
   198 0000017C E86B000000              				call private.fOpen
   199 00000181 B900000000              				mov rcx, 0
   200 00000186 C3                      				ret	
   201                                  			.target_found:
   202 00000187 B901000000              				mov rcx, 1
   203 0000018C C3                      				ret
   204                                  				
   205                                  		;IN: rax = AdjecentNode, rdx = CurrentNode.
   206                                  		;OUT: rcx = 1 if node was updated, else 0.
   207                                  		.fUpdate:
   208                                  			;compute new g cost
   209 0000018D 4C8B82[00000000]        			mov r8, [rdx + Node.GCost]
   210 00000194 4D89C1                  			mov r9, r8
   211 00000197 4C8B90[00000000]        			mov r10, [rax + Node.Resistance]
   212 0000019E 4981E2FFFF0000          			and r10, 0xFFFF
   213 000001A5 4C0FAF15(00000000)      			imul r10, [Node.BaseCost]
   214 000001AD 4D01D0                  			add r8, r10
   215 000001B0 4C0380[00000000]        			add r8, [rax + Node.HCost]
   216                                  			;if updated f cost is larger then current f cost, don't update
   217 000001B7 4C3B80[00000000]        			cmp r8, [rax + Node.FCost]
   218 000001BE 7F26                    			jg .no_update
   219 000001C0 741B                    			je .tie_breaker
   220                                  			;else update all costs and set new parent; return true
   221                                  			.do_update:
   222                                  				;set current node as adjecent nodes parent
   223 000001C2 488990[00000000]        				mov [rax + Node.PParent], rdx
   224 000001C9 4C8988[00000000]        				mov [rax + Node.GCost], r9
   225 000001D0 4C8980[00000000]        				mov [rax + Node.FCost], r8
   226 000001D7 B901000000              				mov rcx, 1
   227 000001DC C3                      				ret
   228                                  			.tie_breaker:
   229                                  				;if f-costs are equal and path is shorter, do update
   230 000001DD 4C3B88[00000000]        				cmp r9, [rax + Node.GCost]
   231 000001E4 7CDC                    				jl .do_update
   232                                  			.no_update:
   233 000001E6 B900000000              				mov rcx, 0
   234 000001EB C3                      				ret
   235                                  		
   236                                  		;IN: rax = AdjecentNode.
   237                                  		;OUT: rcx = 0 if new node or new top node, 1 if new bottom node.
   238                                  		.fOpen:
   239 000001EC 4C8B85[00000000]        			mov r8, [rbp + NodeOpenList.First]
   240 000001F3 4983F8FF                			cmp qword r8, -1
   241 000001F7 7417                    			jz .first
   242 000001F9 4D8B90[00000000]        			mov r10, [r8 + Node.FCost]
   243 00000200 4C3B90[00000000]        			cmp r10, [rax + Node.FCost]
   244 00000207 7F15                    			jg .new_first
   245 00000209 E82D000000              			call private.fSortedInsert
   246 0000020E EB23                    			jmp .open_done
   247                                  			.first:
   248 00000210 488985[00000000]        				mov [rbp + NodeOpenList.First], rax
   249 00000217 B900000000              				mov rcx, 0
   250 0000021C EB15                    				jmp .open_done
   251                                  			.new_first:
   252 0000021E 4C8980[00000000]        				mov [rax + Node.PNext], r8
   253 00000225 488985[00000000]        				mov [rbp + NodeOpenList.First], rax
   254 0000022C B901000000              				mov rcx, 1
   255 00000231 EB00                    				jmp .open_done
   256                                  			.open_done:
   257 00000233 48FF85[00000000]        				inc qword [rbp + NodeOpenList.Count]
   258 0000023A C3                      				ret
   259                                  			
   260                                  		;IN: rax = AdjecentNode.
   261                                  		;OUT: rcx = 3 if node was allocated based on f-cost, rcx = 4 if node was allocated based on h-cost.
   262                                  		.fSortedInsert:
   263 0000023B 4C8B85[00000000]        			mov r8, [rbp + NodeOpenList.First]	;save first in open list = current node
   264 00000242 488B98[00000000]        			mov rbx, [rax + Node.FCost]			;save adjecents f-cost
   265 00000249 488B90[00000000]        			mov rdx, [rax + Node.HCost]			;save adjecents h-cost
   266                                  			.next_open_node:
   267 00000250 4D89C2                  				mov r10, r8						;get next topframe
   268 00000253 4D8B80[00000000]        				mov r8, [r8 + Node.PNext]		;save current topframes next node
   269 0000025A 4983F8FF                				cmp qword r8, -1				;if topframes next node is unset
   270 0000025E 7416                    				jz .new_last					;new last node
   271                                  				;check costs
   272                                  				;mov r9, [rax + Node.FCost]		;save adjecents f-cost
   273 00000260 493B98[00000000]        				cmp rbx, [r8 + Node.FCost]		;compare adjecents f-cost with topframes f-cost
   274 00000267 7FE7                    				jg .next_open_node				;if adjecent is more f-expensive, start new frame
   275 00000269 7C18                    				jl .node_is_cheaper_f			;if adjecent is f-cheaper, link sequence
   276                                  				;tie-breaker 
   277                                  				;mov r9, [rax + Node.HCost]		;save adjecents h-cost
   278 0000026B 493B90[00000000]        				cmp rdx, [r8 + Node.HCost]		;compare adjecents h-cost with topfames h-cost
   279 00000272 7FDC                    				jg .next_open_node				;if adjecent is more h-expensive, start new frame
   280 00000274 7E14                    				jle .node_is_cheaper_h			;if adjecent is h-cheaper or equal, link sequence
   281                                  				.new_last:
   282 00000276 498982[00000000]        					mov [r10 + Node.PNext], rax	;link current topframe to adjecent
   283 0000027D B902000000              					mov rcx, 2					;return 2
   284 00000282 C3                      					ret
   285                                  				.node_is_cheaper_f:
   286 00000283 B903000000              					mov rcx, 3					;return 3
   287 00000288 EB07                    					jmp .node_is_cheaper
   288                                  				.node_is_cheaper_h:
   289 0000028A B904000000              					mov rcx, 4 					;return 4
   290 0000028F EB00                    					jmp .node_is_cheaper
   291                                  				.node_is_cheaper:
   292 00000291 498982[00000000]        					mov [r10 + Node.PNext], rax	;link current topframe to adjecent
   293 00000298 4C8980[00000000]        					mov [rax + Node.PNext], r8	;link adjecent to topframes next node
   294 0000029F C3                      					ret
   295                                  
   296                                  		;Removes node on top of stack, saves values in regs.
   297                                  		.fPop:
   298 000002A0 5D                      			pop rbp			;caller addr
   299 000002A1 49FF89[00000000]        			dec qword [r9 + NodeStack.Count]
   300                                  			;pop sequence
   301 000002A8 58                      			pop rax			;Node.PNext
   302 000002A9 5B                      			pop rbx			;Node.PParent
   303 000002AA 5A                      			pop rdx			;Node.ID
   304 000002AB 4158                    			pop r8			;Node.FCost
   305 000002AD 4159                    			pop r9			;Node.HCost
   306 000002AF 415A                    			pop r10			;Node.GCost
   307 000002B1 415B                    			pop r11			;Node.Closed
   308 000002B3 415C                    			pop r12			;Node.Traversable
   309 000002B5 415D                    			pop r13			;Node.Resistance
   310 000002B7 415E                    			pop r14			;Node.Position.Y
   311 000002B9 415F                    			pop r15			;Node.Position.X
   312                                  			;save top ptr
   313 000002BB 4989A1[00000000]        			mov [r9 + NodeStack.Top], rsp
   314                                  			;return
   315 000002C2 55                      			push rbp
   316 000002C3 C3                      			ret
   317                                  			
   318                                  		;Uses rsi,rdi to access data segment. 
   319                                  		;Removes node on top of stack, faster then PopTop.
   320                                  		.fRemoveTop:
   321 000002C4 5D                      			pop rbp
   322                                  			;call sequence
   323 000002C5 E807000000              			call private.fStackDeallocOne
   324 000002CA E833000000              			call private.fSaveTopAfterRet
   325                                  			;ret
   326 000002CF 55                      			push rbp
   327 000002D0 C3                      			ret
   328                                  			
   329                                  		;deallocates top node
   330                                  		.fStackDeallocOne:
   331                                  			;dec node counter
   332 000002D1 49FF89[00000000]        			dec qword [r9 + NodeStack.Count]
   333                                  			;ret and remove last node
   334 000002D8 C2[0000]                			ret Node.Size
   335                                  			
   336                                  		;deallocates all nodes
   337                                  		.fStackDeallocAll:
   338 000002DB 5F                      			pop rdi
   339                                  			;remove all nodes
   340 000002DC 48BE-                   			mov rsi, Node.Size
   340 000002DE [0000000000000000] 
   341 000002E6 490FAFB1[00000000]      			imul rsi, [r9 + NodeStack.Count]
   342 000002EE 4801F4                  			add rsp, rsi
   343 000002F1 4883C458                			add rsp, 88
   344                                  			;null node counter
   345 000002F5 49C781[00000000]00-     			mov qword [r9 + NodeStack.Count], 0
   345 000002FD 000000             
   346 00000300 57                      			push rdi
   347 00000301 C3                      			ret
   348                                  			
   349                                  		;saves top ptr after correctly a ret needed for some subroutines
   350                                  		.fSaveTopAfterRet:
   351                                  			;save base ptr
   352 00000302 4889A5[00000000]        			mov [rbp + NodeStack.Top], rsp
   353 00000309 8385[00000000]08        			add dword [rbp + NodeStack.Top], 0x8
   354 00000310 C3                      			ret
   355                                  			
   356                                  		;saves top ptr
   357                                  		.fSaveTopBeforeRet:
   358                                  			;save base ptr
   359 00000311 4889A5[00000000]        			mov [rbp + NodeStack.Top], rsp
   360 00000318 C3                      			ret
